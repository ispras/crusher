## Набор примеров
Набор примеров фаззинга на Linux, в которых демонстрируется часть функционала `Crusher`:

1) [python](python) - фаззинг через файл;
2) [jasper](jasper) - фаззинг через файл с использованием DSE (динамическое символьное выполнение);
3) [faad](faad) - фаззинг через аргументы командной строки;
4) [OpenSSL](OpenSSL) - фаззинг OpenSSL-сервера: Peach Pit + ISP_PRELOAD;
5) [stm32](stm32) - фаззинг ПО устройства ARM (на основе частичной эмуляции с Lua-Qemu);
6) [firmware_x86_32](firmware_x86_32) - фаззинг ПО устройства x86 (32-бит) (на основе частичной эмуляции с Lua-Qemu);
7) [firmware_x86_64]( firmware_x86_64) - фаззинг ПО устройства x86 (64-бит) (на основе частичной эмуляции с Lua-Qemu);
8) [fullsystem_emulation](fullsystem_emulation) - фаззинг с полносистемной эмуляцией х86 (64-бит) (на основе частичной эмуляции с Lua-Qemu);
9) [qiling](qiling) - фаззинг с частичной эмуляцией с помощью Qiling;
10) [unicorn](unicorn) - фаззинг с помощью эмулятора Unicorn;
11) [partial_emulation](partial_emulation) - пример частичной эмуляции с помощью модуля DualEmu, комбинирующего фаззинг с помощью unicornafl и DSE с Angr;
12) [java](java) - фаззинг JAVA приложения через файл;
13) [python_fuzz](python_fuzz) - фаззинг библиотеки на языке python;
14) [c#](csharp) - фаззинг dll библиотек, написанных на C#, через файл и stdin;
15) [nginx_docker](nginx_docker) - фаззинг сервера Nginx в Docker-режиме;
16) [OpenSSL_mod_client](OpenSSL_mod_client) - фаззинг OpenSSL-сервера методом модифицированного клиента;
17) [arm_rootfs_gzip](arm_rootfs_gzip) - фаззинг gzip из Ubuntu20 (ARM) с применением Qemu (user-mode);
17) [pytorch](pytorch) - фаззинг python-модуля pytorch;
18) [kern_netfilter](kern_netfilter) - фаззинг компонента ядра с использованием снимков памяти (снапшотов).

Далее приведена последовательность действий по фаззингу, мониторингу и воспроизведению аварийных завершений (крешей) для следующих примеров: `python`, `jasper` и `faad`.


Для остальных примеров подробные инструкции можно найти в файлах `README.md` в соответствующих директориях.

## Запуск фаззинга
В директории примера есть скрипт `fuzz.sh` для запуска фаззинга.
Данному скрипту нужно передать 2 опции:
* `-f </path/to/crusher/bin_x86-64/fuzz_manager>` - путь до исполняемого файла `fuzz_manager`;
* `-c <num>` - число ядер для фаззинга.

Результаты будут записываться в папку `out`.

Пример запуска фаззинга приложения:
```bash
./fuzz.sh -f /path/to/crusher/bin_x86-64/fuzz_manager -c 4
```

## Мониторинг фаззинга
Для мониторинга фаззинга нужно запустить в другом терминале `UI` (User Interface - пользовательский интерфейс) через исполняемый файл `./bin_86-64/ui` (из релиза `Crusher`), который принимает в качестве аргумента путь до соответствующей директории с результатами фаззинга.

Например, для мониторинга фаззинга приложения выполните команду (укажите актуальные пути):
```bash
/path/to/crusher/bin_x86-64/ui -o /path/to/out
```

В каждом примере фаззинг приводит к нахождению аварийных завершений (крешей).
В правом верхнем углу окна пользовательского интерфейса можно наблюдать окно `Stats`. В нём обратите внимание на поле `unique_crashes`.
Как только будет найдено аварийное завершение, значение поля `unique_crashes` станет ненулевым. Пока значение поля нулевое - не останавливайте фаззинг.
Желательно дождаться, когда значение поля будет больше 1. После этого можно остановить фаззинг:

* в терминале с `UI` (пользовательский интерфейс) - для выхода из `UI` нажмите кнопку `q`;
* в терминале с запущенным фаззингом завершите фаззинг по комбинации клавиш `Ctrl+C`.

## Воспроизведение аварийных завершений
1) Для получения списка найденных файлов-крешей (кроме случая фаззинга аргументов командной строки) выполните команду (укажите актуальный путь до out-директории):
```bash
find out -name id_crash_*
```

2) В скрипте `fuzz.sh` после символов `--` прописана команда запуска приложения. Например, для `python` она выглядит так:
```bash
./python-2.5 __DATA__
```

Далее возможны 2 случая:
а) в случае фаззинга файла (как в примере `python`) - выполните вышеуказанную команду, заменив последовательность символов `__DATA__` на один из путей к креш-файлу, полученных в пункте 1), например:
```bash
./python-2.5 out/FUZZ-MASTER_0/crashes/id_crash_0
```

б) в случае фаззинга argv (аргументов командной строки, как в примере `faad`) - выполните вышеуказанную команду, заменив последовательность символов `__DATA__` на `$(cat out/EAT_OUT/results/crashes/000000/replay/data)`,
где `out/EAT_OUT/results/crashes/000000/replay/data` - пример пути к креш-файлу. Входные данные для воспроизведения находятся в out/EAT_OUT/results/crashes/<ID>/replay/data, где ID - номер креша.

Пример команды:
```bash
LD_PRELOAD=./libfaad.so.2 ./faad $(cat out/EAT_OUT/results/crashes/000000/replay/data)
```

Обратите внимание, что для `faad` указывается через `LD_PRELOAD` библиотека, от которой он зависит и которой может не быть в системе.
Во время фаззинга это обеспечивается путём выставления в скрипте `fuzz.sh` переменной окружения `ISP_PRELOAD`, которая обеспечивает использование этой библиотеки только в процессе `faad`,
а не для всех процессов фаззинга (`fuzz_manager`, `fuzz`, `eat` и др.).

3) Наблюдаем аварийное завершение: сообщение в терминале, содержащее `Segmentation fault` или `Aborted`.
   Если соответствующих сообщений не было выведено, то нужно повторить пункты 1)-3) на другом файле.
